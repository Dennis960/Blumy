import os
import logging

from OCP import IFSelect
from OCP.STEPCAFControl import STEPCAFControl_Reader
from OCP.TCollection import TCollection_ExtendedString
from OCP.TDataStd import TDataStd_Name
from OCP.TDF import TDF_ChildIterator, TDF_LabelSequence, TDF_Label
from OCP.TDocStd import TDocStd_Document
from OCP.TopoDS import TopoDS_Shape
from OCP.XCAFDoc import XCAFDoc_DocumentTool

import pickle
import cadquery as cq
from serializer import register
register()


class BoardConverter:
    def __init__(self, cache_dir="parts/"):
        """
        :param cache_dir: Path to the cache directory where the board is saved as step file
        """
        self.base_dir = os.path.dirname(os.path.realpath(__file__)) + "/"
        self.cache_dir = os.path.join(self.base_dir, cache_dir)
        self.cache_already_exists = self._create_cache_dir()

    def from_kicad_pcb(self, kicad_pcb_path: str, step_file: str = "board.step", uses_kicad_nightly_cli=True):
        """
        Converts the kicad_pcb file to a step file and loads the individual components as TopoDS_Shape into a dictionary.\n

        :param kicad_pcb_path: Absolute path to the kicad_pcb file
        :param step_file: Name of the file to be saved in the cache directory
        :param uses_kicad_nightly_cli: Whether to use kicad-cli or kica-cli-nightly

        :return: A dictionary of names and TopoDS_Shape objects.
        """
        step_path = os.path.join(self.cache_dir, step_file)
        self._convert_kicad_pcb_to_step(
            kicad_pcb_path, step_path, uses_kicad_nightly_cli)
        return self.from_step_file(step_file)

    def from_step_file(self, step_file: str) -> dict[str, TopoDS_Shape]:
        """
        Loads the individual components from the step file as TopoDS_Shape into a dictionary.\n
        Currently only guaranteed to work with the step file generated by the from_kicad_pcb function.\n

        :param step_file: Name of the step file in the cache directory

        :return: A dictionary of names and TopoDS_Shape objects.
        """
        step_path = os.path.join(self.cache_dir, step_file)
        doc = TDocStd_Document(TCollection_ExtendedString("doc"))
        reader = STEPCAFControl_Reader()
        status = reader.ReadFile(step_path)
        if status != IFSelect.IFSelect_RetDone:
            logging.error(f"Error reading file {step_path}")
            exit()

        reader.Transfer(doc)
        shapeTool = XCAFDoc_DocumentTool.ShapeTool_s(doc.Main())

        shapes: dict[str, TopoDS_Shape] = {}
        freeShapes = TDF_LabelSequence()
        shapeTool.GetFreeShapes(freeShapes)
        if freeShapes.Length() != 1:
            logging.error(
                f"Expected 1 free shape, found {freeShapes.Length()}")
            exit()
        board_shape = shapeTool.GetShape_s(
            freeShapes.Value(1))

        tdf_iterator = TDF_ChildIterator(freeShapes.Value(1))
        while tdf_iterator.More():
            label = tdf_iterator.Value()
            tdf_iterator.Next()
            if shapeTool.IsShape_s(label):
                shape = shapeTool.GetShape_s(label)

                refLabel = TDF_Label()
                nameAttr = TDataStd_Name()
                if shapeTool.GetReferredShape_s(label, refLabel):
                    if refLabel.FindAttribute(TDataStd_Name.GetID_s(), nameAttr):
                        name = nameAttr.Get().ToExtString()
                newName = name
                i = 1
                while newName in shapes:
                    newName = name + f" ({i})"
                    i += 1
                shapes[newName] = shape
            else:
                logging.warn(f"Label {label} is not a shape")
        return board_shape, shapes

    def _create_cache_dir(self):
        if os.path.exists(self.cache_dir):
            return True
        logging.info("Creating part cache directory")
        os.makedirs(self.cache_dir)
        return False

    def _convert_kicad_pcb_to_step(self, kicad_pcb_path: str, step_path: str, uses_kicad_nightly_cli: bool):
        """
        Converts the kicad_pcb file to a step file.\n
        Saves the step file to the cache directory.\n

        :param kicad_pcb_path: Absolute path to the kicad_pcb file
        :param step_path: Absolute output path for the step file
        :param uses_kicad_nightly_cli: Whether to use kicad-cli or kica-cli-nightly
        """
        if "\"" in kicad_pcb_path or "\"" in step_path:
            logging.error("Paths with \" are not supported")
            exit()
        logging.info("Converting " + kicad_pcb_path + " to " + step_path)
        kicad_nightly_cli_cmd = f"kicad-cli-nightly pcb export step \"{kicad_pcb_path}\" --drill-origin --no-dnp --subst-models -o \"{step_path}\""
        # --no-dnp is not supported in kicad-cli yet
        kicad_cli_cmd = f"kicad-cli pcb export step {kicad_pcb_path} --drill-origin --subst-models -o {step_path}"
        cmd = kicad_nightly_cli_cmd if uses_kicad_nightly_cli else kicad_cli_cmd
        print(f"Running command: {cmd}")
        os.system(cmd)  # TODO make this command save to execute

    def save_to_pickle(self, board_shape: TopoDS_Shape, shapes_dict: dict[str, TopoDS_Shape], pickle_file: str = "board.pickle"):
        """
        Pickles the board_shape and shapes_dict to a file.

        :param board_shape: The board shape
        :param shapes_dict: A dictionary of names and TopoDS_Shape objects.
        :param pickle_file: Path to the pickle file
        """
        pickle_path = os.path.join(self.cache_dir, pickle_file)
        # convert TopoDS_Shapes to cq.Shapes
        board_shape = cq.Shape.cast(board_shape)
        shapes_dict = {name: cq.Shape.cast(shape) for name,
                       shape in shapes_dict.items()}
        with open(pickle_path, "wb") as file:
            pickle.dump((board_shape, shapes_dict), file)

    def _create_assembly(self, shapes_dict: dict[str, TopoDS_Shape]) -> cq.Assembly:
        """
        Creates an assembly where the shapes_dict shapes are the children with their corresponding names.

        :param board_shape: The board shape
        :param shapes_dict: The dictionary of names and TopoDS_Shape objects.
        """
        assembly = cq.Assembly(name="board")
        for name, shape in shapes_dict.items():
            assembly = assembly.add(cq.Workplane(cq.Shape(shape)), name=name)
        return assembly

    def save_assembly(self, shapes_dict: dict[str, TopoDS_Shape], assembly_file: str, exportType: cq.exporters.ExportLiterals | None = None, tolerance: float = 0.1, angularTolerance: float = 0.1):
        """
        Creates an assembly where the board_shape is the parent and the shapes_dict are the children.\n
        Save assembly to a file.

        :shapes_dict: The dictionary of names and TopoDS_Shape objects.
        :param assembly_file: Name of the file to be saved in the cache directory
        :param tolerance: the deflection tolerance, in model units. Only used for GLTF, VRML. Default 0.1.
        :param angularTolerance: the angular tolerance, in radians. Only used for GLTF, VRML. Default 0.1.
        :param exportType: export format (default: None, results in format being inferred form the path)
        """
        assembly_path = os.path.join(self.cache_dir, assembly_file)
        assembly = self._create_assembly(shapes_dict)
        assembly.save(assembly_path, exportType=exportType,
                      tolerance=tolerance, angularTolerance=angularTolerance)

    def from_pickle(self, pickle_file: str = "board.pickle") -> tuple[TopoDS_Shape, dict[str, TopoDS_Shape]]:
        """
        Unpickles the board_shape and shapes_dict from a file.
        :param pickle_file: Path to the pickle file
        """
        pickle_path = os.path.join(self.cache_dir, pickle_file)
        with open(pickle_path, "rb") as file:
            board_shape, shapes_dict = pickle.load(file)
        # convert cq.Shapes to TopoDS_Shapes
        board_shape = board_shape.wrapped
        shapes_dict = {name: shape.wrapped for name,
                       shape in shapes_dict.items()}
        return board_shape, shapes_dict


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    (BoardConverter()
     .from_kicad_pcb("/workspaces/ESPlant/ESPlant-Board/ESPlant-Board.kicad_pcb")
     )
