import os
import logging

from OCP import IFSelect
from OCP.STEPCAFControl import STEPCAFControl_Reader
from OCP.TCollection import TCollection_ExtendedString
from OCP.TDataStd import TDataStd_Name
from OCP.TDF import TDF_ChildIterator, TDF_LabelSequence, TDF_Label
from OCP.TDocStd import TDocStd_Document
from OCP.TopoDS import TopoDS_Shape
from OCP.XCAFDoc import XCAFDoc_DocumentTool


class BoardConverter:
    def __init__(self, cache_dir="parts/"):
        """
        :param cache_dir: Path to the cache directory where the board is saved as step file
        """
        self.base_dir = os.path.dirname(os.path.realpath(__file__)) + "/"
        self.cache_dir = os.path.join(self.base_dir, cache_dir)
        self.cache_already_exists = self._create_cache_dir()
        self.step_path = os.path.join(self.cache_dir, "board.step")
        self.exclude: list[str] = []

    def exclude_parts(self, *exclude):
        """
        Set the parts to exclude from the conversion.
        :param exclude: List of part names to exclude. Does not need to be the full name, only a part of it.
        (e.g. "PinHeader" will exclude all parts that contain "PinHeader" in their name, such as "PinHeader_1x2")
        """
        if len(exclude) == 1 and type(exclude[0]) == list:
            exclude = exclude[0]
        self.exclude = exclude
        return self

    def from_kicad_pcb(self, kicad_pcb_path: str, uses_kicad_nightly_cli=True, force_reconvert=False):
        """
        Converts the kicad_pcb file to a step file and loads the individual components as TopoDS_Shape into a dictionary.\n
        :param kicad_pcb_path: Path to the kicad_pcb file
        :param uses_kicad_nightly_cli: Whether to use kicad-cli or kica-cli-nightly
        :param force_reconvert: Whether to force reconvert the step data

        :return: A dictionary of names and TopoDS_Shape objects.
        """
        if not self.cache_already_exists or force_reconvert:
            self.convert_kicad_pcb_to_step(
                kicad_pcb_path, self.step_path, uses_kicad_nightly_cli)
        return self.from_step_file(self.step_path)

    def from_step_file(self, step_path: str) -> dict[str, TopoDS_Shape]:
        """
        Loads the individual components from the step file as TopoDS_Shape into a dictionary.\n
        Currently only guaranteed to work with the step file generated by the from_kicad_pcb function.\n
        :param step_path: Path to the step file

        :return: A dictionary of names and TopoDS_Shape objects.
        """
        doc = TDocStd_Document(TCollection_ExtendedString("doc"))
        reader = STEPCAFControl_Reader()
        status = reader.ReadFile(step_path)
        if status != IFSelect.IFSelect_RetDone:
            logging.error(f"Error reading file {step_path}")
            exit()

        reader.Transfer(doc)
        shapeTool = XCAFDoc_DocumentTool.ShapeTool_s(doc.Main())

        shapes: dict[str, TopoDS_Shape] = {}
        freeShapes = TDF_LabelSequence()
        shapeTool.GetFreeShapes(freeShapes)
        if freeShapes.Length() != 1:
            logging.error(
                f"Expected 1 free shape, found {freeShapes.Length()}")
            exit()
        board_shape = shapeTool.GetShape_s(
            freeShapes.Value(1))

        tdf_iterator = TDF_ChildIterator(freeShapes.Value(1))
        while tdf_iterator.More():
            label = tdf_iterator.Value()
            tdf_iterator.Next()
            if shapeTool.IsShape_s(label):
                shape = shapeTool.GetShape_s(label)

                refLabel = TDF_Label()
                nameAttr = TDataStd_Name()
                if shapeTool.GetReferredShape_s(label, refLabel):
                    if refLabel.FindAttribute(TDataStd_Name.GetID_s(), nameAttr):
                        name = nameAttr.Get().ToExtString()
                newName = name
                i = 1
                while newName in shapes:
                    newName = name + f" ({i})"
                    i += 1
                if any([exclude_name in newName for exclude_name in self.exclude]):
                    logging.info(f"Excluding {name}")
                    continue
                shapes[newName] = shape
            else:
                logging.warn(f"Label {label} is not a shape")
        return board_shape, shapes

    def _create_cache_dir(self):
        if os.path.exists(self.cache_dir):
            return True
        logging.info("Creating part cache directory")
        os.makedirs(self.cache_dir)
        return False

    def convert_kicad_pcb_to_step(self, kicad_pcb_path: str, step_path: str, uses_kicad_nightly_cli: bool):
        """
        Converts the kicad_pcb file to a step file.\n
        :param kicad_pcb_path: Path to the kicad_pcb file
        :param step_path: Output path for the step file
        :param uses_kicad_nightly_cli: Whether to use kicad-cli or kica-cli-nightly
        """
        logging.info("Converting " + kicad_pcb_path + " to " + step_path)
        kicad_nightly_cli_cmd = f"kicad-cli-nightly pcb export step {kicad_pcb_path} --drill-origin --no-dnp --subst-models -o {step_path}"
        # --no-dnp is not supported in kicad-cli yet
        kicad_cli_cmd = f"kicad-cli pcb export step {kicad_pcb_path} --drill-origin --subst-models -o {step_path}"
        cmd = kicad_nightly_cli_cmd if uses_kicad_nightly_cli else kicad_cli_cmd
        os.system(cmd)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    (BoardConverter()
     .exclude_parts("PinHeader")
     .from_kicad_pcb("ESPlant-Board/ESPlant-Board.kicad_pcb", force_reconvert=True)
     )
